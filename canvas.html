<html>
    <head>

    </head>
    <body>
        <canvas id="canvas" tabindex="1" width="80%" height="900"></canvas>

        <!--<p id="downlog">Down</p>
        <p id="movelog">Move</p>
        <p id="uplog">Up</p>
        <p id="outlog">Out</p>-->

        <script type="text/javascript" language="javascript">
            var canvas = document.getElementById("canvas");
            var context = canvas.getContext("2d");

            // var canvasOffset=$("#canvas").offset();
            // var offsetX=canvasOffset.left;
            // var offsetY=canvasOffset.top;

            var margin = 10;
            var separation = 10;
            var border = 1;
            var width = 23.75;
            var heigth = 23.75;

            var rhythm = 1;
            var pulses = 4 * rhythm;
            var measures = 4;
            var frequencies = 7;

            var widthPerMeasure = (width * pulses) + (border * (pulses + 1))
            var heigthPerMeasure = (heigth * frequencies) + (border * (frequencies + 1));

            canvas.width  = margin * 2 + widthPerMeasure * (measures + 1);
            canvas.height = margin * 2 + heigthPerMeasure;

            // var widthPerCell = border + width;
            // var heightPerCell = border + heigth;
            // achar a área dos 
            // var p1x = margin + border;
            // var p1y = margin + border;
            // var p2x = margin + widthPerCell - 1;
            // var p2y = margin + heightPerCell - 1;

            // fazer os measures
            // por a separação de measures, guardar em uma variavel pra calculo de distancia
            // fazer array de posições
            // selecionar
            // selecionados
            // remover a seleção

            // canvas transparente, printar canvas
            // http://stackoverflow.com/questions/19132064/transparency-context-fill-style-in-canvas-html5
            // por na lisa de selecionados
            canvas.addEventListener('click', function(e) { handleClick(e) });

            // verificar se é o SHIFT, se for fazer unbind do click
            // abrir a selação de multiplas celulas
            // http://stackoverflow.com/questions/12886286/addeventlistener-for-keydown-on-canvas
            // verificar se é DEL ou BACKSPACE e remover a seleção
            // verificar se são setas e movimentar a selação
            canvas.addEventListener('keydown', function(e) { handleKeyDown(e) });

            // voltar evento do click   
            canvas.addEventListener('keyup', function(e) { handleKeyUp(e) });

            canvas.addEventListener('mousedown', function(e) { handleMouseDown(e) });

            canvas.addEventListener('mouseup', function(e) { handleMouseUp(e) });

            canvas.addEventListener('mousemove', function(e) { handleMouseMove(e) });

            function measure(x, y) {
                context.moveTo(x, y);

                // axis x
                for(i = 0; i <= frequencies; i++) {
                    var line = i == 0 ? 0 : border;

                    for (z = 0; z <= border; z++) {
                        context.moveTo(x, y + (heigth + line) * i + z);
                        context.lineTo(x + (width * pulses) + (border * (pulses + 1)), y + (heigth + line) * i + z);
                    }
                }

                // axis y
                for(i = 0; i <= pulses; i++) {
                    var line = i == 0 ? 0 : border;

                    for (z = 0; z <= border; z++) {
                        context.moveTo(x + (width + line) * i + z, y);
                        context.lineTo(x + (width + line) * i + z, y + (heigth * frequencies) + (border * (frequencies + 1)));
                    }
                }                
            }

            function separationASD(x, y) {
                context.moveTo(x, y);
                
                var line = i == 0 ? 0 : border;

                for (z = 0; z <= border; z++) {
                    context.moveTo(x + (width + line) * i + z, y);
                    context.lineTo(x + (width + line) * i + z, y + (heigth * frequencies) + (border * (frequencies + 1)));
                }   
            }

            function handleClick(e) {
                var i = 1;
            }

            function handleKeyDown(e) {
                var i = 1;
            }

            function handleKeyUp(e) {
                var i = 1;
            }

            function handleMouseDown(e) {
                // mouseX=parseInt(e.clientX-offsetX);
                // mouseY=parseInt(e.clientY-offsetY);
                // $("#downlog").html("Down: "+ mouseX + " / " + mouseY);

                // // Put your mousedown stuff here
            }

            function handleMouseUp(e) {
                // mouseX=parseInt(e.clientX-offsetX);
                // mouseY=parseInt(e.clientY-offsetY);
                // $("#uplog").html("Up: "+ mouseX + " / " + mouseY);

                // // Put your mouseup stuff here
            }

            function handleMouseMove(e) {
                // mouseX=parseInt(e.clientX-offsetX);
                // mouseY=parseInt(e.clientY-offsetY);
                // $("#movelog").html("Move: "+ mouseX + " / " + mouseY);

                // // Put your mousemove stuff here
            }

            context.beginPath();

            for (var w = 0; w <= measures - 1; w++) {
                // isso vai ter que levar em consideração a separação.
                // isso, ou o widthPerMeasure

                var x = w == 0 ? margin : (margin * w) + (margin + widthPerMeasure * w);

                measure(x, margin);
            }

            context.stroke();
            
    </script>
    </body>
</html>
